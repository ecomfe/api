<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-'>/**
</span> * ESUI (Enterprise Simple UI)
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @ignore
 * @file 多步骤导航控件
 * @author otakustay
 */
define(
    function (require) {
        var u  = require(&#39;underscore&#39;);
        var lib = require(&#39;./lib&#39;);
        var Control = require(&#39;./Control&#39;);

<span id='Wizard-method-constructor'><span id='Wizard'>        /**
</span></span>         * 多步骤导航控件
         *
         * 一个简单的展示控件，用于显示多步骤的导航，能区分当前节点，已完成节点，最终节点等
         *
         * @extends Control
         * @constructor
         */
        function Wizard() {
            Control.apply(this, arguments);
        }

<span id='Wizard-property-type'>        /**
</span>         * 控件类型，始终为`&quot;Wizard&quot;`
         *
         * @type {string}
         * @readonly
         * @override
         */
        Wizard.prototype.type = &#39;Wizard&#39;;

<span id='Wizard-method-createMain'>        /**
</span>         * 创建控件主元素
         *
         * @return {HTMLElement}
         * @protected
         * @override
         */
        Wizard.prototype.createMain = function () {
            return document.createElement(&#39;ol&#39;);
        };

<span id='Wizard-method-initOptions'>        /**
</span>         * 初始化参数
         *
         * 如果初始化时未给出{@link Wizard#steps}属性，则按以下规则从主元素下提取：
         *
         * 1. 遍历主元素的所有子元素
         * 2. 使用子元素的文本内容作为节点的`text`属性
         * 3. 使用子元素的`data-for`作为节点的`panel`属性
         *
         * @param {Object} [options] 构造函数传入的参数
         * @protected
         * @override
         */
        Wizard.prototype.initOptions = function (options) {
            var properties = {
                steps: [],
                activeIndex: 0
            };

            var children = lib.getChildren(this.main);
            if (!options.steps &amp;&amp; children.length) {
                properties.steps = u.map(
                    children,
                    function (node) {
                        var config = { text: lib.getText(node) };
                        var panel = node.getAttribute(&#39;data-for&#39;);
                        if (panel) {
                            config.panel = panel;
                        }
                        return config;
                    }
                );
            }

            u.extend(properties, options);

            if (typeof properties.activeIndex === &#39;string&#39;) {
                properties.activeIndex = +properties.activeIndex;
            }

            this.setProperties(properties);
        };

<span id='global-method-togglePanel'>        /**
</span>         * 控制对应面板的显示或隐藏
         *
         * @param {Wizard} wizard 控件实例
         * @param {Object} config 对应的步骤配置项
         * @param {boolean} isActive 是否处于激活状态
         * @ignore
         */
        function togglePanel(wizard, config, isActive) {
            var panel = config &amp;&amp; config.panel &amp;&amp; lib.g(config.panel);

            if (!panel) {
                return;
            }

            var method = isActive ? &#39;removePartClasses&#39; : &#39;addPartClasses&#39;;
            wizard.helper[method](&#39;panel-hidden&#39;, panel);
        }

<span id='Wizard-property-nodeTemplate'>        /**
</span>         * 节点内容的HTML模板
         *
         * 在模板中可以使用以下占位符：
         *
         * - `{string} text`：文本内容，经过HTML转义
         *
         * @type {string}
         */
        Wizard.prototype.nodeTemplate = &#39;&lt;span&gt;${text}&lt;/span&gt;&#39;;

<span id='Wizard-method-getNodeHTML'>        /**
</span>         * 获取节点内容HTML
         *
         * @param {meta.WizardItem} node 节点数据项
         * @return {string} 返回HTML片段
         */
        Wizard.prototype.getNodeHTML = function (node) {
            return lib.format(
                this.nodeTemplate,
                {
                    text: lib.encodeHTML(node.text)
                }
            );
        };

<span id='global-method-getHTML'>        /**
</span>         * 获取导航HTML
         *
         * @param {Wizard} wizard 控件实例
         * @return {string}
         * @ignore
         */
        function getHTML(wizard) {
            var html = &#39;&#39;;

            for (var i = 0; i &lt; wizard.steps.length; i++) {
                var node = wizard.steps[i];

                var classes = wizard.helper.getPartClasses(&#39;node&#39;);
                // 第一步
                if (i === 0) {
                    classes.push.apply(
                        classes,
                        wizard.helper.getPartClasses(&#39;node-first&#39;)
                    );
                }
                // 最后一步
                if (i === wizard.steps.length - 1 &amp;&amp; !wizard.finishText) {
                    classes.push.apply(
                        classes,
                        wizard.helper.getPartClasses(&#39;node-last&#39;)
                    );
                }

                // 当前步之前的一步
                if (i === wizard.activeIndex - 1) {
                    classes.push.apply(
                        classes,
                        wizard.helper.getPartClasses(&#39;node-active-prev&#39;)
                    );
                }
                // 已经完成的步骤
                if (i &lt;= wizard.activeIndex - 1) {
                    classes.push.apply(
                        classes,
                        wizard.helper.getPartClasses(&#39;node-done&#39;)
                    );
                }

                var isActive = i === wizard.activeIndex;
                togglePanel(wizard, node, isActive);
                if (isActive) {
                    classes.push.apply(
                        classes,
                        wizard.helper.getPartClasses(&#39;node-active&#39;)
                    );
                    if (i === wizard.steps.length - 1) {
                        classes.push.apply(
                            classes,
                            wizard.helper.getPartClasses(&#39;node-last-active&#39;)
                        );
                    }
                }

                html += &#39;&lt;li class=&quot;&#39; + classes.join(&#39; &#39;) + &#39;&quot;&gt;&#39;;
                html += wizard.getNodeHTML(node);
                html += &#39;&lt;/li&gt;&#39;;
            }

            if (wizard.finishText) {
                var classes = [].concat(
                    wizard.helper.getPartClasses(&#39;node&#39;),
                    wizard.helper.getPartClasses(&#39;node-last&#39;),
                    wizard.helper.getPartClasses(&#39;node-finish&#39;),
                    wizard.activeIndex === wizard.steps.length
                        ? wizard.helper.getPartClasses(&#39;node-active&#39;)
                        : []
                );
                html += &#39;&lt;li class=&quot;&#39; + classes.join(&#39; &#39;) + &#39;&quot;&gt;&#39;;
                html += &#39;&lt;span&gt;&#39; + wizard.finishText + &#39;&lt;/span&gt;&#39;;
                html += &#39;&lt;/li&gt;&#39;;
            }

            return html;
        }

        var paint = require(&#39;./painters&#39;);
<span id='Wizard-method-repaint'>        /**
</span>         * 渲染自身
         *
         * @method
         * @protected
         * @override
         */
        Wizard.prototype.repaint = paint.createRepaint(
            Control.prototype.repaint,
            {
<span id='Wizard-property-steps'>                /**
</span>                 * @property {meta.WizardItem[]} steps
                 *
                 * 步骤集合
                 */

<span id='Wizard-property-finishText'>                /**
</span>                 * @property {string} [finishText]
                 *
                 * “已完成”状态的显示文字，有此属性则在所有步骤后会加一个纯文本节点
                 */
                name: [&#39;steps&#39;, &#39;finishText&#39;],
                paint: function (wizard) {
                    wizard.main.innerHTML = getHTML(wizard);
                }
            },
            {
<span id='Wizard-property-activeIndex'>                /**
</span>                 * @property {number} activeIndex
                 *
                 * 当前步骤节点的下标
                 */
                name: &#39;activeIndex&#39;,
                paint: function (wizard, value) {
                    // 初始化时`steps`的渲染器会处理掉`activeIndex`，不需要这里
                    if (!wizard.helper.isInStage(&#39;RENDERED&#39;)) {
                        return;
                    }

                    var nodes = wizard.main.getElementsByTagName(&#39;li&#39;);
                    for (var i = nodes.length - 1; i &gt;= 0; i--) {
                        var isActive = i === wizard.activeIndex;
                        togglePanel(wizard, wizard.steps[i], isActive);

                        var node = nodes[i];
                        var method = isActive
                            ? &#39;addPartClasses&#39;
                            : &#39;removePartClasses&#39;;
                        wizard.helper[method](&#39;node-active&#39;, node);

                        if (i === wizard.steps.length - 1) {
                            wizard.helper[method](&#39;node-last-active&#39;, node);
                        }

                        var isDone = i &lt;= (wizard.activeIndex - 1);
                        var method = isDone
                            ? &#39;addPartClasses&#39;
                            : &#39;removePartClasses&#39;;
                        wizard.helper[method](&#39;node-done&#39;, node);

                        var isCurPrev = i === (wizard.activeIndex - 1);
                        var method = isCurPrev
                            ? &#39;addPartClasses&#39;
                            : &#39;removePartClasses&#39;;
                        wizard.helper[method](&#39;node-active-prev&#39;, node);
                    }
                }
            }
        );

<span id='Wizard-method-setProperties'>        /**
</span>         * 批量设置控件的属性值
         *
         * @param {Object} properties 属性值集合
         * @return {Object} `properties`参数中确实变更了的那些属性
         * @fires enter
         */
        Wizard.prototype.setProperties = function (properties) {
            if (properties.hasOwnProperty(&#39;steps&#39;)) {
                // 如果同时有`activeIndex`和`steps`，
                // 则`activeIndex`可以只赋在实例上不丢进更新列表，
                // 因为`getHTML`是会处理这事的
                if (properties.hasOwnProperty(&#39;activeIndex&#39;)) {
                    this.activeIndex = properties.activeIndex;
                    delete properties.activeIndex;
                }
                // 如果没给`activeIndex`，则回到最初那一步
                else {
                    this.activeIndex = 0;
                }

                // 如果同时有`steps`和`finishText`，由于这两个都会引发全刷新，
                // 因此只要保留一个就行了
                if (properties.hasOwnProperty(&#39;finishText&#39;)) {
                    this.finishText = properties.finishText;
                    delete properties.finishText;
                }
            }

            var changes =
                Control.prototype.setProperties.apply(this, arguments);
            if (changes.hasOwnProperty(&#39;steps&#39;)
                || changes.hasOwnProperty(&#39;activeIndex&#39;)
            ) {
<span id='Wizard-event-enter'>                /**
</span>                 * @event enter
                 *
                 * 进入某个步骤时触发
                 */
                this.fire(&#39;enter&#39;);
            }
        };

<span id='Wizard-method-getActiveStep'>        /**
</span>         * 获取当前激活的步骤的{@link meta.WizardItem}对象
         *
         * @return {meta.WizardItem}
         */
        Wizard.prototype.getActiveStep = function () {
            return this.get(&#39;steps&#39;)[this.get(&#39;activeIndex&#39;)];
        };

<span id='Wizard-method-stepNext'>        /**
</span>         * 进入下一步
         */
        Wizard.prototype.stepNext = function () {
            var maxStep = this.finishText
                ? this.steps.length
                : this.steps.length - 1;
            if (this.activeIndex &lt; maxStep) {
                this.set(&#39;activeIndex&#39;, this.activeIndex + 1);
            }
        };

<span id='Wizard-method-stepPrevious'>        /**
</span>         * 进入上一步
         */
        Wizard.prototype.stepPrevious = function () {
            if (this.activeIndex &gt; 0) {
                this.set(&#39;activeIndex&#39;,this.activeIndex - 1);
            }
        };

        require(&#39;./main&#39;).register(Wizard);
        lib.inherits(Wizard, Control);

        return Wizard;
    }
);
</pre>
</body>
</html>
