<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-'>/**
</span> * ESUI (Enterprise Simple UI)
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @ignore
 * @file 选择框组
 * @author otakustay
 */
define(
    function (require) {
        var u = require(&#39;underscore&#39;);
        var lib = require(&#39;./lib&#39;);
        var InputControl = require(&#39;./InputControl&#39;);

<span id='BoxGroup-method-constructor'><span id='BoxGroup'>        /**
</span></span>         * 单选或复选框组控件
         *
         * @extends InputControl
         * @constructor
         */
        function BoxGroup() {
            InputControl.apply(this, arguments);
        }

<span id='BoxGroup-property-type'>        /**
</span>         * 控件类型，始终为`&quot;BoxGroup&quot;`
         *
         * @type {string}
         * @readonly
         * @override
         */
        BoxGroup.prototype.type = &#39;BoxGroup&#39;;

        /*
         * 从已有的DOM中分析出数据源
         *
         * @param {HTMLElement} element 供分析的DOM元素
         * @param {Object} options 输入的配置项
         * @param {string|undefined} options.name 输入控件的名称
         * @param {string} options.boxType 选项框的类型，参考`unknownTypes`
         * @ignore
         */
        function extractDatasourceFromDOM(element, options) {
            // 提取符合以下条件的子`&lt;input&gt;`控件：
            // 
            // - `type`属性已知（基本就是`radio`和`checkbox`）
            // - 二选一：
            //     - 当前控件和`&lt;input&gt;`控件都没有`name`属性
            //     - `&lt;input&gt;`和当前控件的`name`属性相同
            // 
            // 根据以下优先级获得`title`属性：
            // 
            // 1. 有一个`for`属性等于`&lt;input&gt;`的`id`属性的`&lt;label&gt;`元素，则取其文字
            // 2. 取`&lt;input&gt;`的`title`属性
            // 3. 取`&lt;input&gt;`的`value`
            var boxes = element.getElementsByTagName(&#39;input&#39;);
            var labels = element.getElementsByTagName(&#39;label&#39;);

            // 先建个索引方便取值
            var labelIndex = {};
            for (var i = labels.length - 1; i &gt;= 0; i--) {
                var label = labels[i];
                var forAttribute = lib.getAttribute(label, &#39;for&#39;);
                if (forAttribute) {
                    labelIndex[forAttribute] = label;
                }
            }

            var datasource = [];
            var values = [];
            for (var i = 0, length = boxes.length; i &lt; length; i++) {
                var box = boxes[i];
                if (box.type === options.boxType
                    &amp;&amp; (options.name || &#39;&#39;) === box.name // DOM的`name`是字符串
                ) {
                    // 提取`value`和`title`
                    var item = { value: box.value };
                    var label = box.id &amp;&amp; labelIndex[box.id];
                    item.title = label ? lib.getText(label) : &#39;&#39;;
                    if (!item.title) {
                        item.title = 
                            box.title || (box.value === &#39;on&#39; ? box.value : &#39;&#39;);
                    }
                    datasource.push(item);

                    // firefox下的autocomplete机制在reload页面时,
                    // 可能导致box.checked属性不符合预期,
                    // 所以这里采用getAttribute
                    // 参考：http://t.cn/zRTdrVR
                    if (box.getAttribute(&#39;checked&#39;) !== null) {
                        values.push(box.value);
                    }
                }
            }

            options.datasource = datasource;
            if (!options.rawValue &amp;&amp; !options.value) {
                options.rawValue = values;
            }
        }

<span id='BoxGroup-method-initOptions'>        /**
</span>         * 初始化参数
         *
         * @param {Object} [options] 构造函数传入的参数
         * @protected
         * @override
         */
        BoxGroup.prototype.initOptions = function (options) {
            var properties = {
                datasource: [],
                orientation: &#39;horizontal&#39;,
                boxType: &#39;radio&#39;
            };
            u.extend(properties, options);

            if (!properties.datasource.length) {
                extractDatasourceFromDOM(this.main, properties);
            }
            if (!properties.rawValue &amp;&amp; !properties.value) {
                properties.rawValue = [];
            }

            this.setProperties(properties);
        };

<span id='global-method-syncValue'>        /**
</span>         * 同步值
         *
         * @ignore
         */
        function syncValue() {
            var result = u.chain(this.getBoxElements())
                .where({ checked: true })
                .pluck(&#39;value&#39;)
                .value();

            this.rawValue = result;
            this.fire(&#39;change&#39;);
        }

        var itemTemplate = [
            &#39;&lt;label title=&quot;${title}&quot; class=&quot;${wrapperClass}&quot;&gt;&#39;,
                &#39;&lt;input type=&quot;${type}&quot; name=&quot;${name}&quot; id=&quot;${id}&quot;&#39;
                    + &#39; title=&quot;${title}&quot; value=&quot;${value}&quot;${checked} /&gt;&#39;,
                &#39;&lt;span&gt;${title}&lt;/span&gt;&#39;,
            &#39;&lt;/label&gt;&#39;
        ];
        itemTemplate = itemTemplate.join(&#39;&#39;);

<span id='global-method-render'>        /**
</span>         * 渲染控件
         *
         * @param {BoxGroup} group 控件实例
         * @param {Object[]} datasource 数据源对象
         * @param {string} boxType 选择框的类型
         * @ignore
         */
        function render(group, datasource, boxType) {
            // `BoxGroup`只会加`change`事件，所以全清就行
            group.helper.clearDOMEvents();

            var html = &#39;&#39;;

            var classes = [].concat(
                group.helper.getPartClasses(boxType),
                group.helper.getPartClasses(&#39;wrapper&#39;)
            );

            var valueIndex = lib.toDictionary(group.rawValue);

            // 分组的选择框必须有相同的`name`属性，所以哪怕没有也给造一个
            var name = group.name || lib.getGUID();
            for (var i = 0; i &lt; datasource.length; i++) {
                var item = datasource[i];
                var data = {
                    wrapperClass: classes.join(&#39; &#39;),
                    id: group.helper.getId(&#39;box-&#39; + i),
                    type: group.boxType,
                    name: name,
                    title: lib.trim(item.title || item.name || item.text),
                    value: item.value,
                    checked: valueIndex[item.value] ? &#39; checked=&quot;checked&quot;&#39; : &#39;&#39;
                };
                html += lib.format(itemTemplate, data);
            }

            group.main.innerHTML = html;

            // `change`事件不会冒泡的，所以在这里要给一个一个加上
            var eventName = group.main.addEventListener ? &#39;change&#39; : &#39;click&#39;;
            u.each(
                group.getBoxElements(),
                function (box) {
                    this.helper.addDOMEvent(box, eventName, syncValue);
                },
                group
            );
        }

<span id='BoxGroup-method-setProperties'>        /**
</span>         * 批量更新属性并重绘
         *
         * @param {Object} properties 需更新的属性
         * @override
         * @fires change
         */
        BoxGroup.prototype.setProperties = function (properties) {
            // 修改了`datasource`或`boxType`，且没给新的`rawValue`或`value`的时候，
            // 要把`rawValue`清空。由于上层`setProperties`是全等判断，
            // 如果当前`rawValue`正好也是空的，就不要改值了，以免引起`change`事件
            if ((properties.datasource || properties.boxType)
                &amp;&amp; (!properties.rawValue &amp;&amp; !properties.value)
                &amp;&amp; (!this.rawValue || !this.rawValue.length)
            ) {
                properties.rawValue = [];
            }

            var changes = 
                InputControl.prototype.setProperties.apply(this, arguments);
            if (changes.hasOwnProperty(&#39;rawValue&#39;)) {
<span id='BoxGroup-event-change'>                /**
</span>                 * @event change
                 *
                 * 值变化时触发
                 */
                this.fire(&#39;change&#39;);
            }
        };

<span id='BoxGroup-method-repaint'>        /**
</span>         * 重渲染
         *
         * @method
         * @protected
         * @override
         */
        BoxGroup.prototype.repaint = require(&#39;./painters&#39;).createRepaint(
            InputControl.prototype.repaint,
            {
<span id='BoxGroup-property-datasource'>                /**
</span>                 * @property {meta.BoxGroupItem[]} datasource
                 *
                 * 数据源
                 */

<span id='BoxGroup-property-boxType'>                /**
</span>                 * @property {string} boxType
                 *
                 * 选框类型，可以为`radio`表示单选，或`checkbox`表示复选
                 */
                name: [&#39;datasource&#39;, &#39;boxType&#39;],
                paint: render
            },
            {
                name: [&#39;disabled&#39;, &#39;readOnly&#39;],
                paint: function (group, disabled, readOnly) {
                    u.each(
                        group.getBoxElements(),
                        function (box) {
                            box.disabled = disabled;
                            box.readOnly = readOnly;
                        }
                    );
                }
            },
            {
<span id='BoxGroup-property-rawValue'>                /**
</span>                 * @property {string[]} rawValue
                 *
                 * 原始值，无论是`radio`还是`checkbox`，均返回数组
                 *
                 * 当{@link BoxGroup#boxType}值为`radio`时，数组必然只有一项
                 *
                 * @override
                 */
                name: &#39;rawValue&#39;,
                paint: function (group, rawValue) {
                    rawValue = rawValue || [];
                    // 因为`datasource`更换的时候会把`rawValue`清掉，这里再弄回去
                    group.rawValue = rawValue;
                    var map = {};
                    for (var i = 0; i &lt; rawValue.length; i++) {
                        map[rawValue[i]] = true;
                    }

                    u.each(
                        group.getBoxElements(),
                        function (box) {
                            box.checked = map.hasOwnProperty(box.value);
                        }
                    );
                }
            },
            {
<span id='BoxGroup-property-orientation'>                /**
</span>                 * @property {string} [orientation=&quot;horizontal&quot;]
                 *
                 * 选框的放置方向，可以为`vertical`表示纵向，或者`horizontal`表示横向
                 */
                name: &#39;orientation&#39;,
                paint: function (group, orientation) {
                    group.removeState(&#39;vertical&#39;);
                    group.removeState(&#39;horizontal&#39;);
                    group.addState(orientation);
                }
            }
        );

<span id='BoxGroup-method-parseValue'>        /**
</span>         * 将字符串类型的值转换成原始格式
         * 
         * @param {string} value 字符串值
         * @return {string[]}
         * @protected
         * @override
         */
        BoxGroup.prototype.parseValue = function (value) {
<span id='BoxGroup-property-value'>            /**
</span>             * @property {string} [value=&quot;&quot;]
             *
             * `BoxGroup`的字符串形式的值为逗号分隔的多个值
             */
            return value.split(&#39;,&#39;);
        };

        // 保护函数区域

<span id='BoxGroup-method-getBoxElements'>        /**
</span>         * 获取内部的输入元素
         *
         * @return {HTMLElement[]}
         * @protected
         */
        BoxGroup.prototype.getBoxElements = function () {
            return u.where(
                this.main.getElementsByTagName(&#39;input&#39;),
                { type: this.boxType }
            );
        };

        lib.inherits(BoxGroup, InputControl);
        require(&#39;./main&#39;).register(BoxGroup);
        return BoxGroup;
    }
);
</pre>
</body>
</html>
